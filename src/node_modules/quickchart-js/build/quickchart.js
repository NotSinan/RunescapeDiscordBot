"use strict";
var QuickChart = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/cross-fetch/dist/browser-ponyfill.js
  var require_browser_ponyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
      var global2 = typeof self !== "undefined" ? self : exports;
      var __self__ = function() {
        function F() {
          this.fetch = false;
          this.DOMException = global2.DOMException;
        }
        F.prototype = global2;
        return new F();
      }();
      (function(self2) {
        var irrelevant = function(exports2) {
          var support = {
            searchParams: "URLSearchParams" in self2,
            iterable: "Symbol" in self2 && "iterator" in Symbol,
            blob: "FileReader" in self2 && "Blob" in self2 && function() {
              try {
                new Blob();
                return true;
              } catch (e) {
                return false;
              }
            }(),
            formData: "FormData" in self2,
            arrayBuffer: "ArrayBuffer" in self2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name) {
            if (typeof name !== "string") {
              name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
              throw new TypeError("Invalid character in header field name");
            }
            return name.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function(value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
              }, this);
            }
          }
          Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ", " + value : value;
          };
          Headers.prototype["delete"] = function(name) {
            delete this.map[normalizeName(name)];
          };
          Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
          };
          Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
          };
          Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };
          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };
          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push(name);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push([name, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request(input, options) {
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
          }
          Request.prototype.clone = function() {
            return new Request(this, { body: this._bodyInit });
          };
          function decode(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split("=");
                var name = split.shift().replace(/\+/g, " ");
                var value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(":");
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(":").trim();
                headers.append(key, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = "statusText" in options ? options.statusText : "OK";
            this.headers = new Headers(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, { status: 0, statusText: "" });
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, { status, headers: { location: url } });
          };
          exports2.DOMException = self2.DOMException;
          try {
            new exports2.DOMException();
          } catch (err) {
            exports2.DOMException = function(message, name) {
              this.message = message;
              this.name = name;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports2.DOMException.prototype = Object.create(Error.prototype);
            exports2.DOMException.prototype.constructor = exports2.DOMException;
          }
          function fetch2(input, init) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init);
              if (request.signal && request.signal.aborted) {
                return reject(new exports2.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };
              xhr.onerror = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.ontimeout = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.onabort = function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              };
              xhr.open(request.method, request.url, true);
              if (request.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr && support.blob) {
                xhr.responseType = "blob";
              }
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
              if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
            });
          }
          fetch2.polyfill = true;
          if (!self2.fetch) {
            self2.fetch = fetch2;
            self2.Headers = Headers;
            self2.Request = Request;
            self2.Response = Response;
          }
          exports2.Headers = Headers;
          exports2.Request = Request;
          exports2.Response = Response;
          exports2.fetch = fetch2;
          Object.defineProperty(exports2, "__esModule", { value: true });
          return exports2;
        }({});
      })(__self__);
      __self__.fetch.ponyfill = true;
      delete __self__.fetch.polyfill;
      var ctx = __self__;
      exports = ctx.fetch;
      exports.default = ctx.fetch;
      exports.fetch = ctx.fetch;
      exports.Headers = ctx.Headers;
      exports.Request = ctx.Request;
      exports.Response = ctx.Response;
      module.exports = exports;
    }
  });

  // node_modules/javascript-stringify/dist/quote.js
  var require_quote = __commonJS({
    "node_modules/javascript-stringify/dist/quote.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringifyPath = exports.quoteKey = exports.isValidVariableName = exports.IS_VALID_IDENTIFIER = exports.quoteString = void 0;
      var ESCAPABLE = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var META_CHARS = /* @__PURE__ */ new Map([
        ["\b", "\\b"],
        ["	", "\\t"],
        ["\n", "\\n"],
        ["\f", "\\f"],
        ["\r", "\\r"],
        ["'", "\\'"],
        ['"', '\\"'],
        ["\\", "\\\\"]
      ]);
      function escapeChar(char) {
        return META_CHARS.get(char) || `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`;
      }
      function quoteString(str) {
        return `'${str.replace(ESCAPABLE, escapeChar)}'`;
      }
      exports.quoteString = quoteString;
      var RESERVED_WORDS = new Set("break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "));
      exports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
      function isValidVariableName(name) {
        return typeof name === "string" && !RESERVED_WORDS.has(name) && exports.IS_VALID_IDENTIFIER.test(name);
      }
      exports.isValidVariableName = isValidVariableName;
      function quoteKey(key, next) {
        return isValidVariableName(key) ? key : next(key);
      }
      exports.quoteKey = quoteKey;
      function stringifyPath(path, next) {
        let result = "";
        for (const key of path) {
          if (isValidVariableName(key)) {
            result += `.${key}`;
          } else {
            result += `[${next(key)}]`;
          }
        }
        return result;
      }
      exports.stringifyPath = stringifyPath;
    }
  });

  // node_modules/javascript-stringify/dist/function.js
  var require_function = __commonJS({
    "node_modules/javascript-stringify/dist/function.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FunctionParser = exports.dedentFunction = exports.functionToString = exports.USED_METHOD_KEY = void 0;
      var quote_1 = require_quote();
      var METHOD_NAMES_ARE_QUOTED = {
        " "() {
        }
      }[" "].toString().charAt(0) === '"';
      var FUNCTION_PREFIXES = {
        Function: "function ",
        GeneratorFunction: "function* ",
        AsyncFunction: "async function ",
        AsyncGeneratorFunction: "async function* "
      };
      var METHOD_PREFIXES = {
        Function: "",
        GeneratorFunction: "*",
        AsyncFunction: "async ",
        AsyncGeneratorFunction: "async *"
      };
      var TOKENS_PRECEDING_REGEXPS = new Set("case delete else in instanceof new return throw typeof void , ; : + - ! ~ & | ^ * / % < > ? =".split(" "));
      exports.USED_METHOD_KEY = /* @__PURE__ */ new WeakSet();
      var functionToString = (fn, space, next, key) => {
        const name = typeof key === "string" ? key : void 0;
        if (name !== void 0)
          exports.USED_METHOD_KEY.add(fn);
        return new FunctionParser(fn, space, next, name).stringify();
      };
      exports.functionToString = functionToString;
      function dedentFunction(fnString) {
        let found;
        for (const line of fnString.split("\n").slice(1)) {
          const m = /^[\s\t]+/.exec(line);
          if (!m)
            return fnString;
          const [str] = m;
          if (found === void 0)
            found = str;
          else if (str.length < found.length)
            found = str;
        }
        return found ? fnString.split(`
${found}`).join("\n") : fnString;
      }
      exports.dedentFunction = dedentFunction;
      var FunctionParser = class {
        constructor(fn, indent, next, key) {
          this.fn = fn;
          this.indent = indent;
          this.next = next;
          this.key = key;
          this.pos = 0;
          this.hadKeyword = false;
          this.fnString = Function.prototype.toString.call(fn);
          this.fnType = fn.constructor.name;
          this.keyQuote = key === void 0 ? "" : quote_1.quoteKey(key, next);
          this.keyPrefix = key === void 0 ? "" : `${this.keyQuote}:${indent ? " " : ""}`;
          this.isMethodCandidate = key === void 0 ? false : this.fn.name === "" || this.fn.name === key;
        }
        stringify() {
          const value = this.tryParse();
          if (!value) {
            return `${this.keyPrefix}void ${this.next(this.fnString)}`;
          }
          return dedentFunction(value);
        }
        getPrefix() {
          if (this.isMethodCandidate && !this.hadKeyword) {
            return METHOD_PREFIXES[this.fnType] + this.keyQuote;
          }
          return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];
        }
        tryParse() {
          if (this.fnString[this.fnString.length - 1] !== "}") {
            return this.keyPrefix + this.fnString;
          }
          if (this.fn.name) {
            const result = this.tryStrippingName();
            if (result)
              return result;
          }
          const prevPos = this.pos;
          if (this.consumeSyntax() === "class")
            return this.fnString;
          this.pos = prevPos;
          if (this.tryParsePrefixTokens()) {
            const result = this.tryStrippingName();
            if (result)
              return result;
            let offset = this.pos;
            switch (this.consumeSyntax("WORD_LIKE")) {
              case "WORD_LIKE":
                if (this.isMethodCandidate && !this.hadKeyword) {
                  offset = this.pos;
                }
              case "()":
                if (this.fnString.substr(this.pos, 2) === "=>") {
                  return this.keyPrefix + this.fnString;
                }
                this.pos = offset;
              case '"':
              case "'":
              case "[]":
                return this.getPrefix() + this.fnString.substr(this.pos);
            }
          }
        }
        tryStrippingName() {
          if (METHOD_NAMES_ARE_QUOTED) {
            return;
          }
          let start = this.pos;
          const prefix = this.fnString.substr(this.pos, this.fn.name.length);
          if (prefix === this.fn.name) {
            this.pos += prefix.length;
            if (this.consumeSyntax() === "()" && this.consumeSyntax() === "{}" && this.pos === this.fnString.length) {
              if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {
                start += prefix.length;
              }
              return this.getPrefix() + this.fnString.substr(start);
            }
          }
          this.pos = start;
        }
        tryParsePrefixTokens() {
          let posPrev = this.pos;
          this.hadKeyword = false;
          switch (this.fnType) {
            case "AsyncFunction":
              if (this.consumeSyntax() !== "async")
                return false;
              posPrev = this.pos;
            case "Function":
              if (this.consumeSyntax() === "function") {
                this.hadKeyword = true;
              } else {
                this.pos = posPrev;
              }
              return true;
            case "AsyncGeneratorFunction":
              if (this.consumeSyntax() !== "async")
                return false;
            case "GeneratorFunction":
              let token = this.consumeSyntax();
              if (token === "function") {
                token = this.consumeSyntax();
                this.hadKeyword = true;
              }
              return token === "*";
          }
        }
        consumeSyntax(wordLikeToken) {
          const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\xA0-\uFFFF]+)|=>|\+\+|\-\-|.)/);
          if (!m)
            return;
          const [token, match] = m;
          this.consumeWhitespace();
          if (match)
            return wordLikeToken || match;
          switch (token) {
            case "(":
              return this.consumeSyntaxUntil("(", ")");
            case "[":
              return this.consumeSyntaxUntil("[", "]");
            case "{":
              return this.consumeSyntaxUntil("{", "}");
            case "`":
              return this.consumeTemplate();
            case '"':
              return this.consumeRegExp(/^(?:[^\\"]|\\.)*"/, '"');
            case "'":
              return this.consumeRegExp(/^(?:[^\\']|\\.)*'/, "'");
          }
          return token;
        }
        consumeSyntaxUntil(startToken, endToken) {
          let isRegExpAllowed = true;
          for (; ; ) {
            const token = this.consumeSyntax();
            if (token === endToken)
              return startToken + endToken;
            if (!token || token === ")" || token === "]" || token === "}")
              return;
            if (token === "/" && isRegExpAllowed && this.consumeMatch(/^(?:\\.|[^\\\/\n[]|\[(?:\\.|[^\]])*\])+\/[a-z]*/)) {
              isRegExpAllowed = false;
              this.consumeWhitespace();
            } else {
              isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);
            }
          }
        }
        consumeMatch(re) {
          const m = re.exec(this.fnString.substr(this.pos));
          if (m)
            this.pos += m[0].length;
          return m;
        }
        consumeRegExp(re, token) {
          const m = re.exec(this.fnString.substr(this.pos));
          if (!m)
            return;
          this.pos += m[0].length;
          this.consumeWhitespace();
          return token;
        }
        consumeTemplate() {
          for (; ; ) {
            this.consumeMatch(/^(?:[^`$\\]|\\.|\$(?!{))*/);
            if (this.fnString[this.pos] === "`") {
              this.pos++;
              this.consumeWhitespace();
              return "`";
            }
            if (this.fnString.substr(this.pos, 2) === "${") {
              this.pos += 2;
              this.consumeWhitespace();
              if (this.consumeSyntaxUntil("{", "}"))
                continue;
            }
            return;
          }
        }
        consumeWhitespace() {
          this.consumeMatch(/^(?:\s|\/\/.*|\/\*[^]*?\*\/)*/);
        }
      };
      exports.FunctionParser = FunctionParser;
    }
  });

  // node_modules/javascript-stringify/dist/array.js
  var require_array = __commonJS({
    "node_modules/javascript-stringify/dist/array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.arrayToString = void 0;
      var arrayToString = (array, space, next) => {
        const values = array.map(function(value, index) {
          const result = next(value, index);
          if (result === void 0)
            return String(result);
          return space + result.split("\n").join(`
${space}`);
        }).join(space ? ",\n" : ",");
        const eol = space && values ? "\n" : "";
        return `[${eol}${values}${eol}]`;
      };
      exports.arrayToString = arrayToString;
    }
  });

  // node_modules/javascript-stringify/dist/object.js
  var require_object = __commonJS({
    "node_modules/javascript-stringify/dist/object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.objectToString = void 0;
      var quote_1 = require_quote();
      var function_1 = require_function();
      var array_1 = require_array();
      var objectToString = (value, space, next, key) => {
        if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
          return `Buffer.from(${next(value.toString("base64"))}, 'base64')`;
        }
        if (typeof global === "object" && value === global) {
          return globalToString(value, space, next, key);
        }
        const toString = OBJECT_TYPES[Object.prototype.toString.call(value)];
        return toString ? toString(value, space, next, key) : void 0;
      };
      exports.objectToString = objectToString;
      var rawObjectToString = (obj, indent, next, key) => {
        const eol = indent ? "\n" : "";
        const space = indent ? " " : "";
        const values = Object.keys(obj).reduce(function(values2, key2) {
          const fn = obj[key2];
          const result = next(fn, key2);
          if (result === void 0)
            return values2;
          const value = result.split("\n").join(`
${indent}`);
          if (function_1.USED_METHOD_KEY.has(fn)) {
            values2.push(`${indent}${value}`);
            return values2;
          }
          values2.push(`${indent}${quote_1.quoteKey(key2, next)}:${space}${value}`);
          return values2;
        }, []).join(`,${eol}`);
        if (values === "")
          return "{}";
        return `{${eol}${values}${eol}}`;
      };
      var globalToString = (value, space, next) => {
        return `Function(${next("return this")})()`;
      };
      var OBJECT_TYPES = {
        "[object Array]": array_1.arrayToString,
        "[object Object]": rawObjectToString,
        "[object Error]": (error, space, next) => {
          return `new Error(${next(error.message)})`;
        },
        "[object Date]": (date) => {
          return `new Date(${date.getTime()})`;
        },
        "[object String]": (str, space, next) => {
          return `new String(${next(str.toString())})`;
        },
        "[object Number]": (num) => {
          return `new Number(${num})`;
        },
        "[object Boolean]": (bool) => {
          return `new Boolean(${bool})`;
        },
        "[object Set]": (set, space, next) => {
          return `new Set(${next(Array.from(set))})`;
        },
        "[object Map]": (map, space, next) => {
          return `new Map(${next(Array.from(map))})`;
        },
        "[object RegExp]": String,
        "[object global]": globalToString,
        "[object Window]": globalToString
      };
    }
  });

  // node_modules/javascript-stringify/dist/stringify.js
  var require_stringify = __commonJS({
    "node_modules/javascript-stringify/dist/stringify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toString = void 0;
      var quote_1 = require_quote();
      var object_1 = require_object();
      var function_1 = require_function();
      var PRIMITIVE_TYPES = {
        string: quote_1.quoteString,
        number: (value) => Object.is(value, -0) ? "-0" : String(value),
        boolean: String,
        symbol: (value, space, next) => {
          const key = Symbol.keyFor(value);
          if (key !== void 0)
            return `Symbol.for(${next(key)})`;
          return `Symbol(${next(value.description)})`;
        },
        bigint: (value, space, next) => {
          return `BigInt(${next(String(value))})`;
        },
        undefined: String,
        object: object_1.objectToString,
        function: function_1.functionToString
      };
      var toString = (value, space, next, key) => {
        if (value === null)
          return "null";
        return PRIMITIVE_TYPES[typeof value](value, space, next, key);
      };
      exports.toString = toString;
    }
  });

  // node_modules/javascript-stringify/dist/index.js
  var require_dist = __commonJS({
    "node_modules/javascript-stringify/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringify = void 0;
      var stringify_1 = require_stringify();
      var quote_1 = require_quote();
      var ROOT_SENTINEL = Symbol("root");
      function stringify2(value, replacer, indent, options = {}) {
        const space = typeof indent === "string" ? indent : " ".repeat(indent || 0);
        const path = [];
        const stack = /* @__PURE__ */ new Set();
        const tracking = /* @__PURE__ */ new Map();
        const unpack = /* @__PURE__ */ new Map();
        let valueCount = 0;
        const { maxDepth = 100, references = false, skipUndefinedProperties = false, maxValues = 1e5 } = options;
        const valueToString = replacerToString(replacer);
        const onNext = (value2, key) => {
          if (++valueCount > maxValues)
            return;
          if (skipUndefinedProperties && value2 === void 0)
            return;
          if (path.length > maxDepth)
            return;
          if (key === void 0)
            return valueToString(value2, space, onNext, key);
          path.push(key);
          const result2 = builder(value2, key === ROOT_SENTINEL ? void 0 : key);
          path.pop();
          return result2;
        };
        const builder = references ? (value2, key) => {
          if (value2 !== null && (typeof value2 === "object" || typeof value2 === "function" || typeof value2 === "symbol")) {
            if (tracking.has(value2)) {
              unpack.set(path.slice(1), tracking.get(value2));
              return valueToString(void 0, space, onNext, key);
            }
            tracking.set(value2, path.slice(1));
          }
          return valueToString(value2, space, onNext, key);
        } : (value2, key) => {
          if (stack.has(value2))
            return;
          stack.add(value2);
          const result2 = valueToString(value2, space, onNext, key);
          stack.delete(value2);
          return result2;
        };
        const result = onNext(value, ROOT_SENTINEL);
        if (unpack.size) {
          const sp = space ? " " : "";
          const eol = space ? "\n" : "";
          let wrapper = `var x${sp}=${sp}${result};${eol}`;
          for (const [key, value2] of unpack.entries()) {
            const keyPath = quote_1.stringifyPath(key, onNext);
            const valuePath = quote_1.stringifyPath(value2, onNext);
            wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;
          }
          return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;
        }
        return result;
      }
      exports.stringify = stringify2;
      function replacerToString(replacer) {
        if (!replacer)
          return stringify_1.toString;
        return (value, space, next, key) => {
          return replacer(value, space, (value2) => stringify_1.toString(value2, space, next, key), key);
        };
      }
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    default: () => src_default
  });
  var import_cross_fetch = __toESM(require_browser_ponyfill());
  var import_javascript_stringify = __toESM(require_dist());
  var SPECIAL_FUNCTION_REGEX = /['"]__BEGINFUNCTION__(.*?)__ENDFUNCTION__['"]/g;
  function doStringify(chartConfig) {
    const str = (0, import_javascript_stringify.stringify)(chartConfig);
    if (!str) {
      return void 0;
    }
    return str.replace(SPECIAL_FUNCTION_REGEX, "$1");
  }
  function postJson(url, payload) {
    return (0, import_cross_fetch.default)(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
  }
  var QuickChart = class {
    constructor(apiKey, accountId) {
      this.apiKey = apiKey;
      this.accountId = accountId;
      this.host = "quickchart.io";
      this.scheme = "https";
      this.baseUrl = `${this.scheme}://${this.host}`;
      this.chart = void 0;
      this.width = 500;
      this.height = 300;
      this.devicePixelRatio = 1;
      this.backgroundColor = "#ffffff";
      this.format = "png";
      this.version = "2.9.4";
    }
    setConfig(chartConfig) {
      this.chart = typeof chartConfig === "string" ? chartConfig : doStringify(chartConfig);
      return this;
    }
    setWidth(width) {
      this.width = width;
      return this;
    }
    setHeight(height) {
      this.height = height;
      return this;
    }
    setBackgroundColor(color) {
      this.backgroundColor = color;
      return this;
    }
    setDevicePixelRatio(ratio) {
      this.devicePixelRatio = ratio;
      return this;
    }
    setFormat(fmt) {
      this.format = fmt;
      return this;
    }
    setVersion(version) {
      this.version = version;
      return this;
    }
    isValid() {
      if (!this.chart) {
        return false;
      }
      return true;
    }
    getUrlObject() {
      if (!this.isValid()) {
        throw new Error("You must call setConfig before getUrl");
      }
      const ret = new URL(`${this.baseUrl}/chart`);
      ret.searchParams.append("c", this.chart);
      ret.searchParams.append("w", String(this.width));
      ret.searchParams.append("h", String(this.height));
      if (this.devicePixelRatio !== 1) {
        ret.searchParams.append("devicePixelRatio", String(this.devicePixelRatio));
      }
      if (this.backgroundColor) {
        ret.searchParams.append("bkg", this.backgroundColor);
      }
      if (this.format) {
        ret.searchParams.append("f", this.format);
      }
      if (this.version) {
        ret.searchParams.append("v", this.version);
      }
      if (this.apiKey) {
        ret.searchParams.append("key", this.apiKey);
      }
      return ret;
    }
    getUrl() {
      return this.getUrlObject().href;
    }
    getSignedUrl() {
      if (!this.accountId || !this.apiKey) {
        throw new Error("You must set accountId and apiKey in the QuickChart constructor to use getSignedUrl()");
      }
      const crypto = __require("crypto");
      const urlObj = this.getUrlObject();
      const chartStr = urlObj.searchParams.get("c");
      const signature = crypto.createHmac("sha256", this.apiKey).update(chartStr).digest("hex");
      urlObj.searchParams.append("sig", signature);
      urlObj.searchParams.append("accountId", this.accountId);
      urlObj.searchParams.delete("key");
      return urlObj.href;
    }
    getPostData() {
      if (!this.isValid()) {
        throw new Error("You must call setConfig creating post data");
      }
      const { width, height, chart, format, version, backgroundColor, devicePixelRatio, apiKey } = this;
      const postData = {
        width,
        height,
        chart
      };
      if (format) {
        postData.format = format;
      }
      if (version) {
        postData.version = version;
      }
      if (backgroundColor) {
        postData.backgroundColor = backgroundColor;
      }
      if (devicePixelRatio) {
        postData.devicePixelRatio = devicePixelRatio;
      }
      if (apiKey) {
        postData.key = apiKey;
      }
      return postData;
    }
    getShortUrl() {
      return __async(this, null, function* () {
        if (!this.isValid()) {
          throw new Error("You must call setConfig before getUrl");
        }
        if (this.host !== "quickchart.io") {
          throw new Error("Short URLs must use quickchart.io host");
        }
        const resp = yield postJson(`${this.baseUrl}/chart/create`, this.getPostData());
        if (!resp.ok) {
          const quickchartError = resp.headers.get("x-quickchart-error");
          const details = quickchartError ? `
${quickchartError}` : "";
          throw new Error(`Chart shorturl creation failed with status code ${resp.status}${details}`);
        }
        const json = yield resp.json();
        if (!json || !json.success || !json.url) {
          throw new Error("Received failure response from chart shorturl endpoint");
        } else {
          return json.url;
        }
      });
    }
    toBinary() {
      return __async(this, null, function* () {
        if (!this.isValid()) {
          throw new Error("You must call setConfig before getUrl");
        }
        const resp = yield postJson(`${this.baseUrl}/chart`, this.getPostData());
        if (!resp.ok) {
          const quickchartError = resp.headers.get("x-quickchart-error");
          const details = quickchartError ? `
${quickchartError}` : "";
          throw new Error(`Chart creation failed with status code ${resp.status}${details}`);
        }
        const data = yield resp.arrayBuffer();
        return Buffer.from(data);
      });
    }
    toDataUrl() {
      return __async(this, null, function* () {
        const buf = yield this.toBinary();
        const b64buf = buf.toString("base64");
        const type = this.format === "svg" ? "svg+xml" : "png";
        return `data:image/${type};base64,${b64buf}`;
      });
    }
    toFile(pathOrDescriptor) {
      return __async(this, null, function* () {
        const fs = __require("fs");
        const buf = yield this.toBinary();
        fs.writeFileSync(pathOrDescriptor, buf);
      });
    }
    static getGradientFillHelper(direction, colors, dimensions) {
      return `__BEGINFUNCTION__getGradientFillHelper(${JSON.stringify(direction)}, ${JSON.stringify(colors)}, ${JSON.stringify(dimensions)})__ENDFUNCTION__`;
    }
    static getGradientFill(colorOptions, linearGradient) {
      return `__BEGINFUNCTION__getGradientFill(${JSON.stringify(colorOptions)}, ${JSON.stringify(linearGradient)})__ENDFUNCTION__`;
    }
    static getImageFill(url) {
      return `__BEGINFUNCTION__getImageFill(${JSON.stringify(url)})__ENDFUNCTION__`;
    }
  };
  QuickChart.pattern = {
    draw: function(shapeType, backgroundColor, patternColor, requestedSize) {
      return `__BEGINFUNCTION__pattern.draw(${JSON.stringify(shapeType)}, ${JSON.stringify(backgroundColor)}, ${JSON.stringify(patternColor)}, ${JSON.stringify(requestedSize)})__ENDFUNCTION__`;
    }
  };
  var src_default = QuickChart;
  return __toCommonJS(src_exports);
})();
QuickChart = QuickChart.default
//# sourceMappingURL=quickchart.js.map
